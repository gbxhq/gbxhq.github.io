<!DOCTYPE HTML>
<html lang="zh-CN">
<head>
    

<head>
    <meta charset="utf-8">
    <meta name="keywords" content="LeetCodeEasy50, 炫杉">
    <meta name="description" content="知识点：Hash、双指针[1]     int的范围[7]     stack、ascii[20]str.substr(pos,n)注意n是步长 [14]     int的范围、牛顿迭代法[69]      copy(1.begin,1.e">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>LeetCodeEasy50 | 炫杉</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/font-awesome.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/css/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery-2.2.0.min.js"></script>
</head>

</head>

<body>

<header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="container">
            <div class="nav-wrapper">
                <div class="brand-logo">
                    <a href="/" class="waves-effect waves-light">
                        
                        <img src="/medias/logo.png" class="logo-img hide-on-small-only">
                        
                        <span class="logo-span">炫杉</span>
                    </a>
                </div>
                <a href="#" data-activates="mobile-nav" class="button-collapse"><i class="fa fa-navicon"></i></a>
<ul class="right">
    
    <li class="hide-on-med-and-down">
        <a href="/" class="waves-effect waves-light">
            
            <i class="fa fa-home"></i>
            
            <span>Index</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/tags" class="waves-effect waves-light">
            
            <i class="fa fa-tags"></i>
            
            <span>Tags</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/categories" class="waves-effect waves-light">
            
            <i class="fa fa-bookmark"></i>
            
            <span>Categories</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/archives" class="waves-effect waves-light">
            
            <i class="fa fa-archive"></i>
            
            <span>Archives</span>
        </a>
    </li>
    
    <li class="hide-on-med-and-down">
        <a href="/about" class="waves-effect waves-light">
            
            <i class="fa fa-user-circle-o"></i>
            
            <span>About</span>
        </a>
    </li>
    
    <li>
        <a id="toggleSearch" class="waves-effect waves-light">
            <i id="searchIcon" class="mdi-action-search"></i>
        </a>
    </li>

</ul>

<div class="side-nav" id="mobile-nav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">炫杉</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li>
            <a href="/" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-home"></i>
                
                Index
            </a>
        </li>
        
        <li>
            <a href="/tags" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-tags"></i>
                
                Tags
            </a>
        </li>
        
        <li>
            <a href="/categories" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-bookmark"></i>
                
                Categories
            </a>
        </li>
        
        <li>
            <a href="/archives" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-archive"></i>
                
                Archives
            </a>
        </li>
        
        <li>
            <a href="/about" class="waves-effect waves-light">
                
                <i class="fa fa-fw fa-user-circle-o"></i>
                
                About
            </a>
        </li>
        
        
    </ul>

    <div class="social-link"><a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>
<a href="mailto:chenjiayin1990@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
    <i class="fa fa-envelope-open"></i>
</a>
<a href="#!" class="tooltipped" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
    <i class="fa fa-qq"></i>
</a>
</div>
</div>

            </div>
        </div>

        
    </nav>
</header>



<div class="bg-cover post-cover" style="background-image: url('/medias/featureimages/14.jpg')">
    <div class="container">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <div class="description center-align post-title">
                        LeetCodeEasy50
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>



<main class="post-container content">

    
    <style>
    #artDetail h1,
    #artDetail h2,
    #artDetail h3,
    #artDetail h4,
    #artDetail h5,
    #artDetail h6 {
        padding-top: 76px;
        margin-top: -76px;
    }

    #artDetail h1 {
        line-height: 3.3rem;
    }

    #artDetail h2 {
        line-height: 3rem;
    }

    #artDetail h3 {
        line-height: 2.5rem;
    }

    #artDetail h4 {
        line-height: 2.2rem;
    }

    #artDetail h5 {
        line-height: 1.9rem;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        padding-left: 20px;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    .post-toc ol {
        padding-left: 20px;
    }

    .post-toc a {
        color: #34495e;
        font-size: 0.96rem;
    }

    .post-toc a:hover {
        color: #42b983;
        text-decoration: underline;
    }

    .post-toc .active {
        color: #42b983;
        font-weight: 500;
    }
</style>
<div class="row">
    <div class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            
            <div class="article-tag">
                
                <a href="/tags/LeetCode/" target="_blank">
                    <span class="chip bg-color">LeetCode</span>
                </a>
                
            </div>
            
            <div class="post-info">
                
                <span class="post-cate">
                    <i class="fa fa-bookmark fa-fw icon-category"></i>
                    
                    <a href="/categories/Algorithm/" class="post-category" target="_blank">
                        Algorithm
                    </a>
                    
                </span>
                

                <span class="post-date">
                    <i class="fa fa-clock-o fa-fw"></i>2018-09-23
                </span>
            </div>
        </div>
        <hr>
        <div class="card-content article-card-content">
            <div id="articleContent">
                <p>知识点：<code>Hash、双指针</code>[1]     <code>int的范围</code>[7]     <code>stack、ascii</code>[20]<br><code>str.substr(pos,n)注意n是步长</code> [14]     <code>int的范围、牛顿迭代法</code>[69]      <code>copy(1.begin,1.end,2.begin)、rbegin\rend</code>[88]      <code>摩尔投票算法</code>[169]   <code>reverse()的理解</code>[189]     <code>位运算</code>[136]   <code>string.erase()</code>[171]     <code>vt.erase()</code>[283]</p>
<a id="more"></a>
<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h1><ul>
<li>朴素法</li>
</ul>
<p>我的第一道LeetCode。上来就暴力解。我还纳闷呢，怎么输出结果和答案都一样。就是过不了。</p>
<p>原来是，时间复杂度为O(N)。过不了的。</p>
<ul>
<li>Hash O(nlogn)</li>
</ul>
<p>哈希表Hash[x]  下标x表示x在nums中的下标。</p>
<p><strong>注意“</strong> map底层使用平衡树一类的数据结构进行实现，插入和查询是O(logn)级别的。</p>
<p>代码</p>
<pre><code class="C++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        std::map&lt;int, int&gt; Hash;
        for (int i = 0; i &lt; nums.size(); ++i)//建Hash
        {
            Hash[nums[i]]= i;
        }
        std::vector&lt;int&gt; ans(2);
        for (int i = 0; i &lt; nums.size(); ++i)
        {
            if (Hash.find(target - nums[i])!=Hash.end()&amp;&amp;Hash[target-nums[i]]!=i)
            {
                ans[0] = i;
                ans[1] = Hash[target-nums[i]];
                break;
            }
        }
        return ans;
    }
};
</code></pre>
<p>上面这个版本更好理解。</p>
<p>然后看到这个版本更简洁。</p>
<pre><code class="C++">class Solution {
public:
    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {
        int N = nums.size();
        vector&lt;int&gt; res;
        map&lt;int ,int&gt; subMap;
        for(int i = 0;i&lt;N;i++)
        {
            int temp = target - nums[i];
            auto it = subMap.find(temp);
            if(it != subMap.end())
            {
                res.push_back(it-&gt;second);
                 res.push_back(i);
            }
            subMap[nums[i]] = i;//i=0时肯定不会输出结果，这样建Hash和判断合二为一。
        }        
        return res;       
    }
};
</code></pre>
<ul>
<li>知识点：</li>
</ul>
<p>为啥要和 <code>map.end()</code> 比较呢？</p>
<blockquote>
<p><strong>修改和查找数据</strong></p>
<p> （1）修改Map[“sunquan”]=11111;</p>
<p> （2）查找数据 用Map.find(key); 可以通过键来查。</p>
<p><strong>切记不要用int value=Map[key];</strong></p>
<p><strong>这样会在Map中增加这个key</strong>，<strong>而value就是缺省值（int 为0，string为空字符串）</strong>。</p>
<p>通过方法（2），会返回迭代器的地址， <strong>key不存在的话迭代器的值为</strong><code>Map.end()</code></p>
</blockquote>
<p>初学map哈哈。</p>
<p><a href="https://www.cnblogs.com/panweiwei/p/6657583.html" target="_blank" rel="noopener">https://www.cnblogs.com/panweiwei/p/6657583.html</a></p>
<h1 id="7-反转整数"><a href="#7-反转整数" class="headerlink" title="7.反转整数"></a>7.反转整数</h1><ul>
<li>正解</li>
</ul>
<pre><code class="c++">class Solution {
public:
    int reverse(int x) {
        if(x==-2147483648)
            return 0;
            int sign ;
    x&gt;0? sign=1: (sign=-1,x=-x);

    long ans=0;

    while(x){
        int tmp = x;
        x = x/10;
        ans = ans*10 + (tmp-x*10);    
    }

    if (ans &gt; INT_MAX)
        return 0;

    return ans*sign;
    }
};
</code></pre>
<ul>
<li>Problems</li>
</ul>
<ol>
<li><p>第一次问题出在ans的类型上。没有存成<code>long</code>。</p>
<p>输入是1534236469时，输出错误。</p>
<p>Int 的范围是 -2^31 ~ 2^31-1，即-2147483648~2147483647</p>
<p>输入1534236469输出应该是9646435461都就90多万了。int最大存21万。</p>
<p>所以应该输出零。而且这个数在ans存的时候要用<code>long</code>型，再和<code>INT_MAX</code>判断一次再return。</p>
</li>
<li><p>改了long之后。1032个用例就差一个过不了了。就是-2147483648。</p>
<p>这个数在我的第一步会被转成正的。而正int里最大是2147483647。存不下2147483648 。所以我直接在第一步判断 return 0了。并不是什么好方法。</p>
</li>
</ol>
<h1 id="9-回文数"><a href="#9-回文数" class="headerlink" title="9.回文数"></a>9.回文数</h1><ul>
<li>解法</li>
</ul>
<pre><code class="c++">class Solution {
public:
    bool isPalindrome(int x) {
    int tmp = x;
    if(x&lt;0)
        return false;
    if(x==0)
        return true;
    if (x%10 == 0)
        return false;

    int y=0;
    while(x){
        y = y*10 + (x%10);
        x = x/10;
    }
    if(y==tmp)
        return true;
    else
        return false;
    }
};
</code></pre>
<ul>
<li>Problems</li>
</ul>
<ol>
<li><p>开始忘了把x先存到tmp中。最后就直接判断<code>y==x</code> 结果每次都是返回false。</p>
<p>很尴尬。x在while中肯定会被改成0啊。</p>
</li>
<li><p>最后一个if只判断了true的情况，忘了写else😂😂😂</p>
</li>
</ol>
<p>低级错误。见笑。</p>
<ul>
<li>知识点  取消cin同步。取消cin与cout绑定。</li>
</ul>
<p>在这题和翻转数字那题的优化解里都看到这么一断：</p>
<pre><code class="c++">//lambda 表达式，可以立即执行，在main函数之前执行，取消输入输出同步，较快输入输出速度
static const auto ban_io_sync = []()
{
    std::ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return 0;
}();
//以后直接当模板用
</code></pre>
<p> <strong><code>std::ios::sync_with_stdio(false)</code></strong></p>
<p>这句语句是用来<strong>取消cin的同步</strong>，什么叫同步呢？就是iostream的缓冲跟stdio的同步。如果你已经在头文件上用了using namespace std;那么就可以去掉前面的std::了。</p>
<p>取消后就cin就不能和scanf，sscanf, getchar, fgets之类同时用了，否则就可能会导致输出和预期的不一样。 </p>
<p>取消同步的目的，是为了让cin不超时，另外<strong>cout的时候尽量少用endl，换用”\n”，也是防止超时的方法</strong>。<br>当然，<strong>尽量用scanf，printf就不用考虑这种因为缓冲的超时</strong>了。</p>
<p> <strong><code>cin.tie(NULL)</code></strong></p>
<p>取消cin与cout的绑定</p>
<hr>
<pre><code>把上一段代码加到我的解法前面，运行时间直接从120ms到了64ms。
</code></pre><hr>
<ul>
<li><p>再看这个解法</p>
<pre><code class="C++">static auto x = []() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    return 0;
}();

class Solution {
public:
    bool isPalindrome(int x) {
        stringstream ss;
        ss &lt;&lt; x;
        string str;
        ss &gt;&gt; str;
        string strTmp = str;
        reverse(str.begin(), str.end());
        if (strTmp == str)
            return true;
        return false;
    }
};
</code></pre>
<p>存成字符串。然后用了个reverse翻转。STL里面啥都有啊。</p>
</li>
</ul>
<h1 id="13-罗马数字转整数"><a href="#13-罗马数字转整数" class="headerlink" title="13.罗马数字转整数"></a>13.罗马数字转整数</h1><ul>
<li>无聊的一题</li>
</ul>
<h1 id="14-最长公共前缀"><a href="#14-最长公共前缀" class="headerlink" title="14.最长公共前缀"></a>14.最长公共前缀</h1><ul>
<li>解</li>
</ul>
<pre><code class="c++">class Solution {
public:
    string Prefix2(string a,string b){
        string ans = &quot;&quot;;
        int p = 0;
        while(p &lt;= (a.size()-1) &amp;&amp; p &lt;= (b.size()-1) ){
                if(a[p] == b [p]){
                        ans += a[p];
                        p++;
                }
                else
                        break;
        }
        return ans;
}
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
    string ans = &quot;&quot;;
    if(strs.size()==0)
        return ans;
    if(strs.size()==1)
        return strs[0];
    auto iter1 = strs.begin();
    while(iter1 != (strs.end()-1)){
        auto iter2 = iter1 +1;
        ans = Prefix2(*iter1,*iter2);
        if(ans == &quot;&quot;)
            break;
        iter1++;
        *iter1 = ans;
    }
    return ans;
}
};
</code></pre>
<p>我的解真是弱爆了。</p>
<p><strong>Problems</strong></p>
<ul>
<li><p>第一次报错</p>
<blockquote>
<p>“Runtime Error Message:reference binding to null pointer of type ‘struct value_type’</p>
<p> Last executed input: []</p>
</blockquote>
<p>百度了一下。<a href="https://blog.csdn.net/zy2317878/article/details/78820900" target="_blank" rel="noopener">https://blog.csdn.net/zy2317878/article/details/78820900</a></p>
<p>我强行加了一句，如果size()是0则返回””</p>
</li>
<li><p>第二次是输入只有1个单词的时候。因为我是自己写了个比较两个单词最长前缀的函数。所以输入只有一个的时候，直接返回了””。正确答案应该是返回这个单词。我又强行加了这么一种情况。</p>
</li>
<li><p>我的解法效率极低。下面去看看大神们怎么解吧。</p>
</li>
</ul>
<p>优化解</p>
<pre><code class="c++">class Solution {
public:
    string longestCommonPrefix(vector&lt;string&gt;&amp; strs) {
        int vec_len=strs.size();
        if(vec_len==0)
            return &quot;&quot;;
        int str_len=strs[0].size();
        for(int i=0;i&lt;str_len;i++)
          for(int j=1;j&lt;vec_len;j++)
            if(strs[j][i]!=strs[0][i])
                return strs[0].substr(0,i);
        return strs[0];
    }
};
</code></pre>
<p>知识点：</p>
<ul>
<li><code>str.substr(x,y)</code>就是取子串。</li>
<li><code>str.substr(0,0)</code>应该就是<code>&quot;&quot;</code></li>
</ul>
<p>这个解的逻辑确实很清晰！</p>
<ul>
<li><p>相同的逻辑，解答里还有一个0ms的写法就是</p>
<p><code>while((strs[0])[i])</code></p>
</li>
</ul>
<h1 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20.有效的括号"></a>20.有效的括号</h1><p><strong>Problems</strong></p>
<ul>
<li><p><code>char</code>类型就用<strong>单引号</strong>啊！！！</p>
<p>之前写 <code>s[i] == &quot;(&quot;</code>一直报错。我就是整不明白为啥报错。</p>
<p><strong>单引号啊！！！</strong></p>
</li>
<li><p><code>vector.end()</code>是地址，而且还是最后一个元素后面的地址。所以最后一个元素应该是</p>
<p><code>*(vector.end()-1)</code> </p>
<p>遍历的话可以用<code>for(auto s:vector)</code></p>
</li>
<li><p>拿过题就用vector声明了一个栈做。不知道有<code>stack</code>都。NAIVE~</p>
</li>
<li><p>判断”)}]”这三种情况的时候应该先看栈里是不是空。再看栈顶的元素。不然如果栈为空，取栈top()会跑不出来。</p>
</li>
<li><p>每次<code>return flase</code>之后都要记得<strong>break</strong>跳出循环啊</p>
</li>
<li><p><strong>vector中v[i]与v.at(i)的区别</strong></p>
<pre><code class="c++">v[0];    // A
v.at[0];  // B
</code></pre>
<p>如果v非空，A行和B行没有任何区别。</p>
<p>如果<strong>v为空或者下标越界</strong>，B行会抛出std::out_of_range异常，A行的行为未定义。</p>
<p>c++标准不要求vector::operator[]进行下标越界检查，原因是为了效率，总是强制下标越界检查会增加程序的性能开销。设计vector是用来代替内置数组的，所以效率问题也应该考虑。不过使用operator[]就要自己承担越界风险了。</p>
<p>如果需要下标越界检查，请使用at。</p>
</li>
</ul>
<p>我的解效率特别差。看一下人家的</p>
<p><strong>优化解</strong></p>
<pre><code class="c++">class Solution {
public:
    bool isValid(string s) {
       stack&lt;char&gt; sta;
    int length = s.length();
    if (length % 2 == 1) return false;
    if (s.empty()) return true;
    for (int i = 0; i &lt; length; i++)
    {
        if (sta.empty())
        {
            sta.push(s.at(i)); 
        }
        else if(sta.top() == s.at(i) - 2 || sta.top() == s.at(i) - 1)
        {
            sta.pop();
        }
        else
        {
            sta.push(s.at(i));
        }
    }
    return sta.empty() ? true : false;
    }
};
</code></pre>
<p>哎！简洁又效率。</p>
<ul>
<li><p>先判断了长度是奇数返回false.为空返回false.</p>
</li>
<li><p>没有瞎判断字符是不是<code>&#39;{([])}&#39;</code></p>
<p>而是利用了ascii码。那为啥有 -1 有 -2 呢？</p>
<p>看了ascii码表你就知道了。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
<th>ASCII值</th>
<th>控制字符</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>NUT</td>
<td>32</td>
<td>(space)</td>
<td>64</td>
<td>@</td>
<td>96</td>
<td>、</td>
</tr>
<tr>
<td>1</td>
<td>SOH</td>
<td>33</td>
<td>!</td>
<td>65</td>
<td>A</td>
<td>97</td>
<td>a</td>
</tr>
<tr>
<td>2</td>
<td>STX</td>
<td>34</td>
<td>“</td>
<td>66</td>
<td>B</td>
<td>98</td>
<td>b</td>
</tr>
<tr>
<td>3</td>
<td>ETX</td>
<td>35</td>
<td>#</td>
<td>67</td>
<td>C</td>
<td>99</td>
<td>c</td>
</tr>
<tr>
<td>4</td>
<td>EOT</td>
<td>36</td>
<td>$</td>
<td>68</td>
<td>D</td>
<td>100</td>
<td>d</td>
</tr>
<tr>
<td>5</td>
<td>ENQ</td>
<td>37</td>
<td>%</td>
<td>69</td>
<td>E</td>
<td>101</td>
<td>e</td>
</tr>
<tr>
<td>6</td>
<td>ACK</td>
<td>38</td>
<td>&amp;</td>
<td>70</td>
<td>F</td>
<td>102</td>
<td>f</td>
</tr>
<tr>
<td>7</td>
<td>BEL</td>
<td>39</td>
<td>,</td>
<td>71</td>
<td>G</td>
<td>103</td>
<td>g</td>
</tr>
<tr>
<td>8</td>
<td>BS</td>
<td><strong>40</strong></td>
<td><strong>(</strong></td>
<td>72</td>
<td>H</td>
<td>104</td>
<td>h</td>
</tr>
<tr>
<td>9</td>
<td>HT</td>
<td><strong>41</strong></td>
<td><strong>)</strong></td>
<td>73</td>
<td>I</td>
<td>105</td>
<td>i</td>
</tr>
<tr>
<td>10</td>
<td>LF</td>
<td>42</td>
<td>*</td>
<td>74</td>
<td>J</td>
<td>106</td>
<td>j</td>
</tr>
<tr>
<td>11</td>
<td>VT</td>
<td>43</td>
<td>+</td>
<td>75</td>
<td>K</td>
<td>107</td>
<td>k</td>
</tr>
<tr>
<td>12</td>
<td>FF</td>
<td>44</td>
<td>,</td>
<td>76</td>
<td>L</td>
<td>108</td>
<td>l</td>
</tr>
<tr>
<td>13</td>
<td>CR</td>
<td>45</td>
<td>-</td>
<td>77</td>
<td>M</td>
<td>109</td>
<td>m</td>
</tr>
<tr>
<td>14</td>
<td>SO</td>
<td>46</td>
<td>.</td>
<td>78</td>
<td>N</td>
<td>110</td>
<td>n</td>
</tr>
<tr>
<td>15</td>
<td>SI</td>
<td>47</td>
<td>/</td>
<td>79</td>
<td>O</td>
<td>111</td>
<td>o</td>
</tr>
<tr>
<td>16</td>
<td>DLE</td>
<td>48</td>
<td>0</td>
<td>80</td>
<td>P</td>
<td>112</td>
<td>p</td>
</tr>
<tr>
<td>17</td>
<td>DCI</td>
<td>49</td>
<td>1</td>
<td>81</td>
<td>Q</td>
<td>113</td>
<td>q</td>
</tr>
<tr>
<td>18</td>
<td>DC2</td>
<td>50</td>
<td>2</td>
<td>82</td>
<td>R</td>
<td>114</td>
<td>r</td>
</tr>
<tr>
<td>19</td>
<td>DC3</td>
<td>51</td>
<td>3</td>
<td>83</td>
<td>S</td>
<td>115</td>
<td>s</td>
</tr>
<tr>
<td>20</td>
<td>DC4</td>
<td>52</td>
<td>4</td>
<td>84</td>
<td>T</td>
<td>116</td>
<td>t</td>
</tr>
<tr>
<td>21</td>
<td>NAK</td>
<td>53</td>
<td>5</td>
<td>85</td>
<td>U</td>
<td>117</td>
<td>u</td>
</tr>
<tr>
<td>22</td>
<td>SYN</td>
<td>54</td>
<td>6</td>
<td>86</td>
<td>V</td>
<td>118</td>
<td>v</td>
</tr>
<tr>
<td>23</td>
<td>TB</td>
<td>55</td>
<td>7</td>
<td>87</td>
<td>W</td>
<td>119</td>
<td>w</td>
</tr>
<tr>
<td>24</td>
<td>CAN</td>
<td>56</td>
<td>8</td>
<td>88</td>
<td>X</td>
<td>120</td>
<td>x</td>
</tr>
<tr>
<td>25</td>
<td>EM</td>
<td>57</td>
<td>9</td>
<td>89</td>
<td>Y</td>
<td>121</td>
<td>y</td>
</tr>
<tr>
<td>26</td>
<td>SUB</td>
<td>58</td>
<td>:</td>
<td>90</td>
<td>Z</td>
<td>122</td>
<td>z</td>
</tr>
<tr>
<td>27</td>
<td>ESC</td>
<td>59</td>
<td>;</td>
<td><strong>91</strong></td>
<td><strong>[</strong></td>
<td><strong>123</strong></td>
<td><strong>{</strong></td>
</tr>
<tr>
<td>28</td>
<td>FS</td>
<td>60</td>
<td>&lt;</td>
<td>92</td>
<td>/</td>
<td>124</td>
<td></td>
</tr>
<tr>
<td>29</td>
<td>GS</td>
<td>61</td>
<td>=</td>
<td><strong>93</strong></td>
<td><strong>]</strong></td>
<td><strong>125</strong></td>
<td><strong>}</strong></td>
</tr>
<tr>
<td>30</td>
<td>RS</td>
<td>62</td>
<td>&gt;</td>
<td>94</td>
<td>^</td>
<td>126</td>
<td>`</td>
</tr>
<tr>
<td>31</td>
<td>US</td>
<td>63</td>
<td>?</td>
<td>95</td>
<td>_</td>
<td>127</td>
<td>DEL</td>
</tr>
</tbody>
</table>
<h1 id="26-删除排序数组中的重复项"><a href="#26-删除排序数组中的重复项" class="headerlink" title="26. 删除排序数组中的重复项"></a>26. 删除排序数组中的重复项</h1><ul>
<li>循环左移之后。记得这一轮就不要让标记位置走到下一个了。</li>
<li>传入空字符串的时候。我的程序会完全没有符合的条件。而导致没有返回值超时。以后要注意写条件的时候就想清楚会不会有特殊情况。</li>
<li>sb了。没看题是排好序的。而且遍历的时候是遍历你返回值n的前n个。</li>
</ul>
<h1 id="27-移除元素"><a href="#27-移除元素" class="headerlink" title="27. 移除元素"></a>27. 移除元素</h1><p>吸收了上一题的答案。直接超越100%：</p>
<pre><code class="c++">int n = 0;
for (int i = 0; i&lt;nums.size();i++){
    if(nums[i]!=val)//只要不是val就存进来
        nums[n++]=nums[i];
}
return n;
</code></pre>
<h1 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a>35. 搜索插入位置</h1><p>PASS</p>
<h1 id="53-最大子序和"><a href="#53-最大子序和" class="headerlink" title="53. 最大子序和"></a>53. 最大子序和</h1><p>暴力写出来了。人家怎么就想到这么写呢：</p>
<pre><code class="c++">int res = INT_MIN, curSum = 0;
for (int num : nums) {
    curSum = max(curSum + num, num);
    res = max(res, curSum);
}
return res;
</code></pre>
<h1 id="66-加一"><a href="#66-加一" class="headerlink" title="66. 加一"></a>66. 加一</h1><p>水</p>
<h1 id="69-x的平方根"><a href="#69-x的平方根" class="headerlink" title="69 x的平方根"></a>69 x的平方根</h1><ul>
<li><p>int 的范围问题。本来用的int。结果人家给的输入。int平方之后就超过了范围了。以后要注意！</p>
</li>
<li><p>牛顿迭代法Mark。还可用用来接多次方程</p>
</li>
</ul>
<h1 id="70爬楼梯"><a href="#70爬楼梯" class="headerlink" title="70爬楼梯"></a>70爬楼梯</h1><p>其实就是斐波那契这题。我用递归写的。<strong>但是！</strong>我的写法，在输入是40以后，就超时咯（我特判了过的）。这么写不错：</p>
<pre><code class="c++">int climbStairs(int n) {
    if (n &lt; 2) return 1;
    int dp0, dp1, dp;
    dp0 = dp1 = 1;
    for (int i = 2; i &lt;= n; i++) {
        dp = dp0 + dp1;
        dp0 = dp1;
        dp1 = dp;
    }
    return dp;
}
</code></pre>
<h1 id="88-合并两个有序数组"><a href="#88-合并两个有序数组" class="headerlink" title="88.合并两个有序数组"></a>88.合并两个有序数组</h1><p>🙂🙂🙂</p>
<p>一晚上我没做出来这题</p>
<ul>
<li><p>结束void函数，直接<code>return;</code></p>
</li>
<li><p>看了提示。从后往前插入。写出来了。速度不行。看一下这个0ms的：</p>
<pre><code class="c++">void merge(vector&lt;int&gt;&amp; nums1, int m, vector&lt;int&gt;&amp; nums2, int n) {
    auto b1 = nums1.rbegin() + n, b2 = nums2.rbegin();
    for (auto cur = nums1.rbegin(); b1 != nums1.rend(); ++cur)
    {
        if (b2 == nums2.rend())
            return;
        if (*b2 &lt; *b1)
            *cur = *b1++;
        else *cur = *b2++;
    }
    copy(b2, nums2.rend(), nums1.rend() - (nums2.rend() - b2));
}
</code></pre>
</li>
</ul>
<h1 id="100-相同的树"><a href="#100-相同的树" class="headerlink" title="100.相同的树"></a>100.相同的树</h1><p>先来看我之前写法：</p>
<pre><code class="c++">bool isSameTree(TreeNode* p, TreeNode* q) {
    if(p&amp;&amp;q)
        if(p-&gt;val!=q-&gt;val)
            return false;
    if(p&amp;&amp;!q)
        return false;
    if(q&amp;&amp;!p)
        return false;
    if(!p&amp;&amp;!q)
        return true;
    if(p-&gt;left&amp;&amp;q-&gt;left) //加上这个if条件是因为不然会因为p\q指向空指针报这个错：member access null pointer of type &#39;struct TreeNode&#39;
        isSameTree(p-&gt;left,q-&gt;left);
    if(p-&gt;right&amp;&amp;q-&gt;right)
        isSameTree(p-&gt;right,q-&gt;right);
    return true;
}
</code></pre>
<p>这写法过不了。师哥改：</p>
<pre><code class="c++">bool isSameTree(TreeNode* p, TreeNode* q) {
    if(p&amp;&amp;q)
        if(p-&gt;val!=q-&gt;val)
            return false;
    if(p&amp;&amp;!q)
        return false;
    if(q&amp;&amp;!p)
        return false;
    if(!p&amp;&amp;!q)
        return true;
    return isSameTree(p-&gt;left,q-&gt;left)
        &amp;&amp;isSameTree(p-&gt;right,q-&gt;right)
        &amp;&amp;p-&gt;val==q-&gt;val;
}//直接返回两个结果&amp;&amp;起来不就解决了吗。这样有一边走到了false都会返回false
</code></pre>
<h1 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101.对称二叉树"></a>101.对称二叉树</h1><ul>
<li><p>开始写成了判断节点的两个孩子是否相同。完全整错了题。</p>
</li>
<li><p>用两个前序遍历把结果存到vector里。一个先遍历左孩子，一个先遍历右孩子。然后比较两个vt相同。</p>
<ul>
<li>Problem，空节点的时候，不会存入vector，导致一些情况判错。解决方法：空节点存入-9999</li>
</ul>
</li>
<li><p>正经的解法：</p>
<pre><code class="c++"> bool symmetric(TreeNode* left, TreeNode* right)
{
    if (!left &amp;&amp; !right)
    {
        return true;
    }
    if (!left || !right)
    {
        return false;
    }
    return left-&gt;val == right-&gt;val &amp;&amp; symmetric(left-&gt;left, right-&gt;right) &amp;&amp; symmetric(left-&gt;right, right-&gt;left);
}
bool isSymmetric(TreeNode* root) 
{
    if (!root)
    {
        return true;
    }
    return symmetric(root-&gt;left, root-&gt;right);
}
</code></pre>
</li>
</ul>
<h1 id="04二叉树的最大深度"><a href="#04二叉树的最大深度" class="headerlink" title="04二叉树的最大深度"></a>04二叉树的最大深度</h1><p>必备</p>
<h1 id="107二叉树的层次遍历-II"><a href="#107二叉树的层次遍历-II" class="headerlink" title="107二叉树的层次遍历 II"></a>107二叉树的层次遍历 II</h1><h1 id="121买股票1"><a href="#121买股票1" class="headerlink" title="121买股票1"></a>121买股票1</h1><p>比较简单。但我第一次用的O(n2)。显得很没水平。只要记录最小值和最大值就可以了。不需要两层循环遍历的。</p>
<h1 id="122买股票2"><a href="#122买股票2" class="headerlink" title="122买股票2"></a>122买股票2</h1><p>有了上一题的启发。很快解决。（本来想半天）</p>
<h1 id="189旋转数组"><a href="#189旋转数组" class="headerlink" title="189旋转数组"></a>189旋转数组</h1><ul>
<li><p>开始想用一个临时数组存原来的数。然后根据需要copy。</p>
<p>结果发现人家让空间复杂度O(1)原地完成。</p>
</li>
<li><p>想到了多次Reverse的方法。这个思路还是很清晰的。以下两点需要注意：</p>
<ul>
<li><p>如vt的内容是 1 2 3 4 5 6 7</p>
<p><code>reverse(vt.begin(),vt.begin()+3)</code>执行后，反转的就是前三个数。变成：</p>
<p>321  4567</p>
<p>虽然vt.begin()+3已经指向了4这个元素。</p>
<p>这也可以解释为什么<code>reverse(vt.begin(),vt.end())</code>在end()指向空的时候，为什么可以翻转整个vector。</p>
</li>
<li><p>输入的位移量大于数组长度的情况要考虑到，取余即可。（怕的是想不到）</p>
</li>
</ul>
</li>
</ul>
<h1 id="136只出现一次的数字"><a href="#136只出现一次的数字" class="headerlink" title="136只出现一次的数字"></a>136只出现一次的数字</h1><p>高端操作：位运算</p>
<ul>
<li>延伸阅读：<a href="https://blog.csdn.net/bitboss/article/details/51594037" target="_blank" rel="noopener">https://blog.csdn.net/bitboss/article/details/51594037</a><ul>
<li>进阶1： <strong>一个数组中，只有一个数字出现了一次，其他数字都出现了三次，找出这个出现了一次的数字；</strong></li>
<li>进阶2：<strong>&lt;百度面试题&gt;：在一个数组中，其他元素都是成对出现，只有两个数字只出现了一次，找出这两个数；</strong></li>
</ul>
</li>
</ul>
<h1 id="151最小栈"><a href="#151最小栈" class="headerlink" title="151最小栈"></a>151最小栈</h1><ul>
<li>可以用<code>*(vt.end()-1)</code>的方式取到vector的最后一个元素啊。</li>
<li></li>
</ul>
<h1 id="两个数组的交集-II"><a href="#两个数组的交集-II" class="headerlink" title="两个数组的交集 II"></a>两个数组的交集 II</h1><p>关于map的遍历：</p>
<ul>
<li>如果输入的map下标不存在则会创建这个下标。</li>
<li>map.find()是查的关键字</li>
</ul>
<h1 id="168-EXCELL表列名"><a href="#168-EXCELL表列名" class="headerlink" title="168 EXCELL表列名"></a>168 EXCELL表列名</h1><p>就是输入1输出A 输入28输出AB</p>
<ul>
<li><p>注意输入26时，余数为0。这种情况需要特判。</p>
<p>输入26时。n的循环也会多走一圈。需要特判。不然输入26会输出ZA。</p>
</li>
<li><p>每轮循环结束是 <code>n = n/26</code> 还是<code>n = n-26</code> ?    请思考清楚</p>
</li>
</ul>
<h1 id="171和168相对"><a href="#171和168相对" class="headerlink" title="171和168相对"></a>171和168相对</h1><p><code>string.erase(pos,len)</code>,从pos位置开始删除len个字符。len缺省则删除到末尾。返回string的一个引用。</p>
<p>比如<code>str.erase(str.size()-5,5);</code> 删除了后5个字符。注意是.size()-5 。就是用下标来控制的。</p>
<p>我个人更喜欢用<code>str = str.substr(pos1,pos2)</code>这种方式删除</p>
<h1 id="169绝对众数"><a href="#169绝对众数" class="headerlink" title="169绝对众数"></a>169绝对众数</h1><ul>
<li>用map做感觉是水题。</li>
</ul>
<p>但是在别人的解法里学到了摩尔投票算法：</p>
<blockquote>
<p>首先请考虑最基本的摩尔投票问题，找出一组数字序列中出现次数大于总数1/2的数字（并且假设这个数字一定存在）。显然这个数字只可能有一个。<strong>摩尔投票算法是基于这个事实：每次从序列里选择两个不相同的数字删除掉（或称为“抵消”），最后剩下一个数字或几个相同的数字，就是出现次数大于总数一半的那个</strong>。</p>
</blockquote>
<ul>
<li>继续延伸：1/k众数</li>
</ul>
<p>Ex:k=3。求1/3众数。注：这样的数可能不存在</p>
<pre><code class="C++">    #include &lt;iostream&gt;
    #include &lt;cstdlib&gt;
    #include &lt;vector&gt;
    #include &lt;iterator&gt;
    using namespace std;

    void FindMode(const int *a, int size, vector&lt;int&gt;&amp; mode){
    int m,n;//候选值
    int cm = 0, cn = 0;//候选值m、n的个数
    int i;
    for(i=0; i&lt;size; i++){
        if(cm == 0){
            m = a[i];
            cm = 1;
        }else if(cn == 0){
            n = a[i];
            cn = 1;
        }else if(m == a[i]){
            cm++;
        }else if(n == a[i]){
            cn++;
        }else{
            cm--;
            cn--;
        }
    }
    //↑ 运行到此处时的m、n一定是众数，同时也是可能存在的1/3众数。

    cm = cn = 0;//为确保一定存在（因为1/3众数可能不存在），一定要重新遍历统计出现次数
    for(i=0; i&lt;size; i++){
        if(m == a[i]){
            cm++;
        }else if(n == a[i]){
            cn++;
        }
    }
    if(cm &gt; size/3){
        mode.push_back(m);
//        cout&lt;&lt; m&lt;&lt;&quot; &quot;;
    }
    if(cn &gt; size/3){
        mode.push_back(n);
//        cout&lt;&lt; n&lt;&lt;&quot; &quot;;
    }

}

void Print(vector&lt;int&gt; vector){
    for(int i=0; i&lt;vector.size(); i++){
        cout&lt;&lt; vector[i]&lt;&lt;&quot; &quot;;
    }
    cout&lt;&lt;endl;
}

int main()
{
    int a[] = {8,1,1,8,1,1,6,1,5,8,8};
    vector&lt;int&gt; mode;
    FindMode(a, sizeof(a)/sizeof(int),mode);
    Print(mode);
    return 0;
}
</code></pre>
<h1 id="172阶乘后的零"><a href="#172阶乘后的零" class="headerlink" title="172阶乘后的零"></a>172阶乘后的零</h1><ul>
<li><p>13的阶乘就已经超INT范围了。用了<code>long long</code>型之后，它给我输入了个30🙂🙂🙂</p>
<p>思路有问题🙃</p>
</li>
<li><p>找到了规律。其实有几个零就是和因子里有几个5有关系。所以遇到 5、25、125、675~这种要处理，可是刁钻的问题出现了。测试用例给了一个1808548329。5的13次方是1220703125。我的算法可以给出答案。但是超时了。后面还有个过不了的用例2147483647。就是INT_MAX呗。超时了。我直接特判了这两个过的。</p>
</li>
<li><p>结果发现0ms的答案只有这么几行：</p>
<pre><code class="c++">int trailingZeroes(int n) {
    long long sum=0;
    for(long long i=5;i&lt;=n;i=i*5)
        sum=sum+n/i;
    return sum;
}
</code></pre>
</li>
</ul>
<p>这时候再回头看一下我自己写的【超时版】答案。其实不就是一个意思吗：</p>
<pre><code class="c++">int ans = n/5; //先除以5
for(int i=2;pow(5,i)&lt;=n;i++){ /*小于25的时候。
里面每有一个25就++(这不就是m/pow(5,2)吗？
我傻不拉几的在那用循环判断每次ans++)*/
    int tmp = n;
    while(tmp&gt;=pow(5,i)){
        ans ++;
        tmp -= pow(5,i);
    }
    cout&lt;&lt;i&lt;&lt;endl;
}
return ans;
</code></pre>
<h1 id="283移动零"><a href="#283移动零" class="headerlink" title="283移动零"></a>283移动零</h1><p>输入 0 1 0 3 2</p>
<p>输出 1 3 2 0 0 </p>
<ul>
<li>注意，用迭代器it控制，vt.erase(it) 时，删除了it指向的元素，且it会指向下一个it。</li>
<li>出现的问题：<ul>
<li>开始我只用迭代器来控制遍历，当迭代器为end时终止遍历，没考虑到，我会不停地在vector尾部push_back(0)，这样遍历永远都不会结束。</li>
</ul>
</li>
</ul>

            </div>
            <hr/>

            
            <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.88rem;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff;
        background-color: #22AB38;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff;
        background-color: #019FE8;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a class="reward-link btn-floating btn-large waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close"><i class="fa fa-close"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs">
                        <li class="tab wechat-tab waves-effect waves-light"><a class="active" href="#wechat">微信</a></li>
                        <li class="tab alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                    </ul>
                    <div id="wechat">
                        <img src="/medias/reward/wechat1.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                    <div id="alipay">
                        <img src="/medias/reward/alipay1.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('#reward .reward-link').on('click', function () {
            $('#rewardModal').openModal();
        });

        $('#rewardModal .close').on('click', function () {
            $('#rewardModal').closeModal();
        });
    });
</script>
            

            <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    <div class="social-share" data-disabled="qzone" data-wechat-qrcode-helper="<p>微信里点“发现”->“扫一扫”二维码便可查看分享。</p>"></div>
    
</div>

<script src="/libs/share/js/social-share.min.js"></script>

            <div class="reprint">
                <p>
                    <span class="reprint-tip">转载请注明: </span>
                    <a href="https://o--o.win" class="b-link-green">炫杉</a>
                    <i class="fa fa-angle-right fa-lg fa-fw text-color"></i>
                    <a href="/LeetCodeEasy50/" class="b-link-green">LeetCodeEasy50</a>
                </p>
            </div>
        </div>
    </div>

    

    

    

    
    <div class="livere-card card" data-aos="fade-up">
    <!-- 来必力City版安装代码 -->
    <div id="lv-container" class="card-content" data-id="city" data-uid="MTAyMC8yOTg2My82NDI5">
        <script type="text/javascript">
            (function (d, s) {
                let j, e = d.getElementsByTagName(s)[0];
                if (typeof LivereTower === 'function') {
                    return;
                }

                j = d.createElement(s);
                j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
                j.async = true;

                e.parentNode.insertBefore(j, e);
            })(document, 'script');
        </script>
        <noscript>为正常使用来必力评论功能请激活JavaScript。</noscript>
    </div>
    <!-- City版安装代码已完成 -->
</div>
    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">上一篇</div>
            <div class="card">
                <a href="/Others/Homebrew的使用/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/20.jpg" class="responsive-img" alt="Homebrew的使用">
                        
                        <span class="card-title">Homebrew的使用</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">Homebrew的使用命令记录 参考：https://www.jianshu.com/p/3016f1897e31和https://www.radyhuang.com/homebrew-cleanup-cache

概念
Mac的软件包管理</div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="fa fa-clock-o fa-fw icon-date"></i>2018-10-15
                        </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Others/" class="post-category" target="_blank">
                                    Others
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Note/" target="_blank">
                        <span class="chip bg-color">Note</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">下一篇</div>
            <div class="card">
                <a href="/Others/Heroku_ssh/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/14.jpg" class="responsive-img" alt="Heroku搭建自己的ss服务器教程">
                        
                        <span class="card-title">Heroku搭建自己的ss服务器教程</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary">Heroku是日本一家网站。为开发者提供了免费部署项目的服务器。虽然访问Heroku是被qiang的。但是用Heroku部署后的应用(saas/web app)其主机在美国和欧洲，且主机地址没有被qiang。利用这一点就可以免费搭建一个自己</div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="fa fa-clock-o fa-fw icon-date"></i>2018-09-12
                            </span>
                        <span class="publish-author">
                            
                            <i class="fa fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Others/" class="post-category" target="_blank">
                                    Others
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/tips/" target="_blank">
                        <span class="chip bg-color">tips</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>
</div>
    </div>
    <div class="col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <h4>目录</h4>
            <div id="toc-content">
                <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#1-两数之和"><span class="post-toc-text">1.两数之和</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#7-反转整数"><span class="post-toc-text">7.反转整数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#9-回文数"><span class="post-toc-text">9.回文数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#13-罗马数字转整数"><span class="post-toc-text">13.罗马数字转整数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#14-最长公共前缀"><span class="post-toc-text">14.最长公共前缀</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#20-有效的括号"><span class="post-toc-text">20.有效的括号</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#26-删除排序数组中的重复项"><span class="post-toc-text">26. 删除排序数组中的重复项</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#27-移除元素"><span class="post-toc-text">27. 移除元素</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#35-搜索插入位置"><span class="post-toc-text">35. 搜索插入位置</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#53-最大子序和"><span class="post-toc-text">53. 最大子序和</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#66-加一"><span class="post-toc-text">66. 加一</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#69-x的平方根"><span class="post-toc-text">69 x的平方根</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#70爬楼梯"><span class="post-toc-text">70爬楼梯</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#88-合并两个有序数组"><span class="post-toc-text">88.合并两个有序数组</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#100-相同的树"><span class="post-toc-text">100.相同的树</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#101-对称二叉树"><span class="post-toc-text">101.对称二叉树</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#04二叉树的最大深度"><span class="post-toc-text">04二叉树的最大深度</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#107二叉树的层次遍历-II"><span class="post-toc-text">107二叉树的层次遍历 II</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#121买股票1"><span class="post-toc-text">121买股票1</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#122买股票2"><span class="post-toc-text">122买股票2</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#189旋转数组"><span class="post-toc-text">189旋转数组</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#136只出现一次的数字"><span class="post-toc-text">136只出现一次的数字</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#151最小栈"><span class="post-toc-text">151最小栈</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#两个数组的交集-II"><span class="post-toc-text">两个数组的交集 II</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#168-EXCELL表列名"><span class="post-toc-text">168 EXCELL表列名</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#171和168相对"><span class="post-toc-text">171和168相对</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#169绝对众数"><span class="post-toc-text">169绝对众数</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#172阶乘后的零"><span class="post-toc-text">172阶乘后的零</span></a></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#283移动零"><span class="post-toc-text">283移动零</span></a></li></ol>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        let tocLinks = $('#toc-content a');
        let setTocLinkActive = function (jqObj) {
            tocLinks.removeClass('active');
            jqObj.addClass('active');
        };

        // 监听点击TOC目录.
        tocLinks.on('click', function () {
            setTocLinkActive($(this));
        });

        let titleTopArr = [];
        $('#articleContent').find('h1, h2, h3, h4, h5, h6').each(function () {
            titleTopArr.push({'id': $(this).attr('id'), 'top': Math.round($(this).offset().top)});
        });
        let titleLen = titleTopArr.length;

        /* 监听滚动条.*/
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();

            /* add post toc fixed. */
            if (scroll > 240) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }

            /** 以下代码为动态设置TOC激活高亮的目录. */
            if (titleLen === 0) {
                return;
            }

            let firstTitleObj = titleTopArr[0];
            if (firstTitleObj.top > scroll) {
                return;
            } else if (firstTitleObj.top === scroll) {
                setTocLinkActive($('#toc-content a[href="#' + firstTitleObj.id + '"]'));
                return;
            }

            let lastTitleObj = titleTopArr[titleLen - 1];
            if (lastTitleObj.top <= scroll) {
                setTocLinkActive($('#toc-content a[href="#' + lastTitleObj.id + '"]'));
                return;
            }

            for (let i = 0; i < titleLen; i++) {
                if (titleTopArr[i].top > scroll) {
                    setTocLinkActive($('#toc-content a[href="#' + titleTopArr[i - 1].id + '"]'));
                    break;
                }
            }
        });
    });
</script>
    

</main>

<footer class="page-footer bg-color">
    <div class="container row center-align">
        <div class="col s12 m8 l8 copy-right">
            本站由&copy;<a href="https://blinkfox.github.io/" target="_blank">Blinkfox</a>基于
            <a href="https://hexo.io/" target="_blank">Hexo</a> 采用
            <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">hexo-theme-matery</a>的主题搭建.
        </div>
        <div class="col s12 m4 l4 social-link"><a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
    <i class="fa fa-github"></i>
</a>
<a href="mailto:chenjiayin1990@163.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
    <i class="fa fa-envelope-open"></i>
</a>
<a href="#!" class="tooltipped" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
    <i class="fa fa-qq"></i>
</a>
</div>
    </div>
</footer>

<div class="progress-bar"></div>


<!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title">搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input" autofocus="">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
</script>
<!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fa fa-angle-up"></i>
    </a>
</div>


<script src="/libs/materialize/js/materialize.min.js"></script>
<script src="/libs/masonry/masonry.pkgd.min.js"></script>
<script src="/libs/aos/aos.js"></script>
<script src="/libs/scrollprogress/scrollProgress.min.js"></script>
<script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
<script src="/js/matery.js"></script>
</body>
</html>