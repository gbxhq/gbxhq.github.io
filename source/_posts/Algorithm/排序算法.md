---
title: 排序算法
date: 2018-11-05 09:36:06
categories: Algorithm
tags: [Algorithm,Sort,Cpp]
---

该和排序算法做个了结了

<!---more--->

# 15种排序算法动态演示

这个视频是在网上看到的。

<iframe frameborder="0" width="100%" height="500px" src="https://v.qq.com/txp/iframe/player.html?vid=t0396emm8oy" allowFullScreen="true"></iframe>

那我们就跟着视频来写出这15种排序算法吧。这15种排序分别是：

[1.简单选择排序](#简单选择排序)
[2.插入排序](#直接插入排序)
[3.快速排序](#快速排序)
[4.合并排序](#合并排序)
[5.堆排序](#堆排序)
[6.基数排序](#基数排序)
[7.最高有效位排序](#最高有效位排序)
[8.内省排序](#内省排序)
[9.适应性归并排序](#适应性归并排序)
[10.希尔排序（缩小增量，插入排序的改进版）](#希尔排序)
[11.冒泡排序](#冒泡排序)
[12.鸡尾酒排序（定向冒泡，选择排序的一种）](#鸡尾酒排序)
[13.地精排序（写法最简单的排序）](#地精排序)
[14.双调排序](#双调排序)
[15.Bogo排序（等量子计算时代唯一的算法，穷举法）](#Bogo排序)

# 简单选择排序

简单选择排序，每次找到一个最小的。放到前面。

效率自然是 O(n2)

# 直接插入排序

加哨兵的核心：

```cpp
for(int i=2;i<n;i++){
        vt[0]=vt[i];
        int j=i-1;
        for(;vt[j]>vt[0];j--)
            vt[j+1] = vt[j];
        vt[j+1] = vt[0];
}
```

作用

- 把每次要插入的目标放到vt[0]的位置，

- 让循环的结束条件`vt[j]>vt[0]` 一定可以结束。

  因为当**目标值**是最小的时候，**第一个元素vt[1]**都比**目标**大，**vt[1]**会后移到**vt[2]**上。

  `j--` 则 j就变成了0  。`vt[0]>vt[0]`不成立，循环结束。且要插入的位置正是 0+1 = 1。目标值放在了位置1上。

# 快速排序

核心就是i和j两个坐标的移动：

```cpp
while (x < vt[j]&&i<j){ 
    j--;
}
if(i<j){//这里只要判断i<j防止已经相遇就好了
    vt[i]=vt[j];
    i++;
}
```

注意的地方：

- 进入快排，先把传入的i和j两个参数存起啦，最后递归的时候要用

- 第一行，不要忘记 `&& i<j`    

  不要写成 <= 。那样会导致和x一样的数没做处理。跳过去了就。

  应当放到x的左侧才对==》**快排是不稳定的**

- 注意上面的第4行，我开始写的是：`if(x>vt[j] && i<j)`。错在哪？

  上一步的循环条件是 `x<vt[j]` **与 < 相对的**不是 > 而**是 >=**啊。

  所以要写成 `x<=vt[j]`，或者不写。

# 合并排序

- 归并的拆分的递归思路特别好。要记住两个函数参数怎么设。
- 需要占用空间啊（要有个临时数组去合并结果）。

# 堆排序

https://www.cs.usfca.edu/~galles/visualization/HeapSort.html

# 基数排序

http://www.cs.usfca.edu/~galles/visualization/RadixSort.html

我完全按照算法的思想。把数一次次存到map里写出来的。

貌似正规的写法不用这么「扯」。

说下我的写法吧：

1. 按个位数当下标key，先全存到第一个map里

2. 建立一个allMap，根据最高位数exp，往allMap里存map。

3. 遍历上一层的map。因为上一层的map是按个位数排好序的。

   取出这个数。判断它的十位。存到这一层的map里。

- map里如果value是存的vector，那不需要初始化就可以直接push_back的。

  比如，`map[1].push_back(99);` 这种写法是没错的。

# 最高有效位排序

这和基数排序啥区别啊。就是从高位开始判断的基数排序？

# 内省排序
# 适应性归并排序 
# 希尔排序
# 冒泡排序
# 鸡尾酒排序
# 地精排序
# 双调排序
# Bogo排序

# 完美排序

思想：
- `if`i位置比j位置小，二者交换。
- 循环结束条件 i等于j
- 三分数组，先递归前2/3。再递归2/3。再递归前2/3

代码美观。
效率低。

[代码下载](/Downloads/sort.cpp)



最后看一个娱乐的。24中排序算法同时运行，拿个更快呢？

<iframe frameborder="0"  width="100%" height="500px"  src="https://v.qq.com/txp/iframe/player.html?vid=x0528v6hypr" allowFullScreen="true"></iframe>

